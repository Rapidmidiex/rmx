package user

import (
	"errors"
	"net/http"
	"strings"
	"time"

	"github.com/rog-golang-buddies/rmx/internal"
	"github.com/rog-golang-buddies/rmx/internal/suid"
)

// var refreshTokenCookieName = "RMX_DIRECT_RT"
// var refreshTokenCookiePath = "/api/v1"

// 400 - catch all
// 401 - unauthorized
// 403 - Forbidden
// 409 - Conflict (details already exist)
// 412 - Invalid precondition
// 422 - Unprocessable

type signup struct {
	Email    internal.Email    `json:"email"`
	Username string            `json:"username"`
	Password internal.Password `json:"password"`
}

func (v signup) decode(iu *internal.User) error {
	h, err := v.Password.Hash()
	if err != nil {
		return err
	}

	*iu = internal.User{
		ID:       suid.NewUUID(),
		Email:    v.Email,
		Username: v.Username,
		Password: h,
	}

	return nil
}

func (s *Service) handleRegistration() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var v signup
		if err := s.decode(w, r, &v); err != nil {
			s.respond(w, r, err, http.StatusBadRequest)
			return
		}

		var u internal.User
		if err := v.decode(&u); err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		if err := s.r.SignUp(u); err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		s.created(w, r, u.ID.String())
	}
}

func (s *Service) handleLogin() http.HandlerFunc {
	type login struct {
		Email    internal.Email    `json:"email"`
		Password internal.Password `json:"password"`
	}

	type response struct {
		IDToken     string `json:"id_token"`
		AccessToken string `json:"access_token"`
	}

	return func(w http.ResponseWriter, r *http.Request) {
		var v login
		if err := s.decode(w, r, &v); err != nil {
			s.respond(w, r, err, http.StatusBadRequest)
			return
		}

		u, err := s.r.LookupEmail(v.Email)
		if err != nil {
			s.respond(w, r, err, http.StatusNotFound)
			return
		}

		if err := u.Password.Compare(v.Password); err != nil {
			s.respond(w, r, err, http.StatusUnauthorized)
			return
		}

		/*
			Claims & Token

			Token generated by the user
		*/

		cookie := &http.Cookie{
			Path:     "REFRESH_TOKEN_COOKIE_PATH",
			Name:     "REFRESH_TOKEN_COOKIE_NAME",
			Value:    "GEN_REFRESH_TOKEN",
			HttpOnly: true,
			Secure:   r.TLS != nil,
			SameSite: http.SameSiteLaxMode,
			Expires:  time.Now().UTC().Add(time.Hour * 24 * 7),
		}

		var data = response{
			IDToken:     "GEN_ID_TOKEN",
			AccessToken: "GEN_ACCESS_TOKEN",
		}

		s.respondCookie(w, r, data, cookie)
	}
}

func (s *Service) handleLogout() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cookie := &http.Cookie{
			Path:     "REFRESH_TOKEN_COOKIE_PATH",
			Name:     "REFRESH_TOKEN_COOKIE_NAME",
			Value:    "",
			HttpOnly: true,
			Secure:   r.TLS != nil,
			SameSite: http.SameSiteLaxMode,
			Expires:  time.Unix(0, 0),
		}

		s.respondCookie(w, r, nil, cookie)
	}
}

func (s *Service) handleRefresh() http.HandlerFunc {
	type response struct {
		AccessToken string
	}

	return func(w http.ResponseWriter, r *http.Request) {
		c, err := r.Cookie("REFRESH_TOKEN_COOKIE_NAME")
		if err != nil {
			s.respond(w, r, err, http.StatusUnauthorized)
			return
		}

		/*
			Claims & Tokens

			Token generated by cookie value
		*/

		*c = http.Cookie{
			Path:     "REFRESH_TOKEN_COOKIE_PATH",
			Name:     "REFRESH_TOKEN_COOKIE_NAME",
			Value:    "GEN_REFRESH_TOKEN",
			HttpOnly: true,
			Secure:   r.TLS != nil,
			SameSite: http.SameSiteLaxMode,
			Expires:  time.Now().UTC().Add(time.Hour * 24 * 7),
		}

		data := response{
			AccessToken: "GEN_ACCESS_TOKEN",
		}

		s.respondCookie(w, r, data, c)
	}
}

func (s *Service) authenticate() func(f http.HandlerFunc) http.HandlerFunc {
	return func(f http.HandlerFunc) http.HandlerFunc {
		const (
			Auth = "Authorization"
		)

		return func(w http.ResponseWriter, r *http.Request) {
			bearer := strings.Split(r.Header.Get(Auth), " ")

			if len(bearer) <= 1 {
				s.respond(w, r, errors.New("invalid session"), http.StatusUnauthorized)
				return
			}

			// context with value
			f(w, r)
		}
	}
}

// NOTE: internal/auth
