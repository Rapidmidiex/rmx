package user

import (
	"context"
	"net/http"
	"time"

	"github.com/lestrrat-go/jwx/v2/jwa"
	"github.com/lestrrat-go/jwx/v2/jwk"
	"github.com/lestrrat-go/jwx/v2/jwt"
	"github.com/rog-golang-buddies/rmx/internal"
	"github.com/rog-golang-buddies/rmx/internal/suid"
)

// var refreshTokenCookieName = "RMX_DIRECT_RT"
// var refreshTokenCookiePath = "/api/v1"

// 400 - catch all
// 401 - unauthorized
// 403 - Forbidden
// 409 - Conflict (details already exist)
// 412 - Invalid precondition
// 422 - Unprocessable

type signupUser struct {
	Email    internal.Email    `json:"email"`
	Username string            `json:"username"`
	Password internal.Password `json:"password"`
}

func (v signupUser) decode(iu *internal.User) error {
	h, err := v.Password.Hash()
	if err != nil {
		return err
	}

	*iu = internal.User{
		ID:       suid.NewUUID(),
		Email:    v.Email,
		Username: v.Username,
		Password: h,
	}

	return nil
}

func (s *Service) handleRegistration() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var v signupUser
		if err := s.decode(w, r, &v); err != nil {
			s.respond(w, r, err, http.StatusBadRequest)
			return
		}

		var u internal.User
		if err := v.decode(&u); err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		if err := s.r.SignUp(u); err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		s.created(w, r, u.ID.String())
	}
}

func (s *Service) handleMyInfo() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		email := r.Context().Value(emailKey).(string)

		s.respond(w, r, email, http.StatusOK)
	}
}

func (s *Service) handleLogin(privateKey, publicKey jwk.Key) http.HandlerFunc {
	type login struct {
		Email    internal.Email    `json:"email"`
		Password internal.Password `json:"password"`
	}

	type response struct {
		IDToken     string `json:"idToken"`
		AccessToken string `json:"accessToken"`
	}

	return func(w http.ResponseWriter, r *http.Request) {
		var v login
		if err := s.decode(w, r, &v); err != nil {
			s.respond(w, r, err, http.StatusBadRequest)
			return
		}

		u, err := s.r.LookupEmail(v.Email)
		if err != nil {
			s.respond(w, r, err, http.StatusNotFound)
			return
		}

		if err := u.Password.Compare(v.Password); err != nil {
			s.respond(w, r, err, http.StatusUnauthorized)
			return
		}

		// -- Generate Tokens --
		var now = time.Now().UTC()
		var jwb = jwt.NewBuilder().Issuer("github.com/rog-golang-buddies/rmx").IssuedAt(now).Claim("email", u.Email)
		// Audience([]string{"http://localhost:3000"}).
		_ = jwb

		idToken, err := jwb.Subject(string(u.Email)).Expiration(now.Add(time.Hour * 10)).Build()
		if err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		idTokenSigned, err := jwt.Sign(idToken, jwt.WithKey(jwa.RS256, privateKey))
		if err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		accessToken, err := jwt.NewBuilder().Subject(u.ID.String()).Expiration(now.Add(time.Minute * 5)).Build()
		if err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		accessTokenSigned, err := jwt.Sign(accessToken, jwt.WithKey(jwa.RS256, privateKey))
		if err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		refreshToken, err := jwt.NewBuilder().Subject(u.ID.String()).Expiration(now.Add(time.Hour * 24 * 7)).Build()
		if err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		refreshTokenSigned, err := jwt.Sign(refreshToken, jwt.WithKey(jwa.RS256, privateKey))
		if err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}
		// -- Generate Tokens --

		cookie := &http.Cookie{
			Name:     "RMX_DIRECT_RT",
			Value:    string(refreshTokenSigned),
			HttpOnly: true,
			Secure:   r.TLS != nil,
			SameSite: http.SameSiteLaxMode,
			Expires:  time.Now().UTC().Add(time.Hour * 24 * 7),
		}

		var data = response{
			IDToken:     string(idTokenSigned),
			AccessToken: string(accessTokenSigned),
		}

		s.respondCookie(w, r, data, cookie)
	}
}

func (s *Service) handleLogout() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cookie := &http.Cookie{
			// Path: "REFRESH_TOKEN_COOKIE_PATH",
			Name:     "RMX_DIRECT_RT",
			Value:    "",
			HttpOnly: true,
			Secure:   r.TLS != nil,
			SameSite: http.SameSiteLaxMode,
			Expires:  time.Unix(0, 0),
		}

		s.respondCookie(w, r, nil, cookie)
	}
}

func (s *Service) handleRefresh() http.HandlerFunc {
	type response struct {
		AccessToken string `json:"accessToken"`
	}

	return func(w http.ResponseWriter, r *http.Request) {
		c, err := r.Cookie("REFRESH_TOKEN_COOKIE_NAME")
		if err != nil {
			s.respond(w, r, err, http.StatusUnauthorized)
			return
		}

		/*
			Claims & Tokens

			Token generated by cookie value
		*/

		*c = http.Cookie{
			Path:     "REFRESH_TOKEN_COOKIE_PATH",
			Name:     "REFRESH_TOKEN_COOKIE_NAME",
			Value:    "GEN_REFRESH_TOKEN",
			HttpOnly: true,
			Secure:   r.TLS != nil,
			SameSite: http.SameSiteLaxMode,
			Expires:  time.Now().UTC().Add(time.Hour * 24 * 7),
		}

		data := response{
			AccessToken: "GEN_ACCESS_TOKEN",
		}

		s.respondCookie(w, r, data, c)
	}
}

func (s *Service) authenticate(privateKey, publicKey jwk.Key) func(f http.Handler) http.Handler {
	return func(f http.Handler) http.Handler {
		fn := func(w http.ResponseWriter, r *http.Request) {
			token, err := jwt.ParseRequest(r, jwt.WithKey(jwa.RS256, publicKey), jwt.WithValidate(true))
			if err != nil {
				s.respond(w, r, err, http.StatusUnauthorized)
				return
			}

			email, ok := token.PrivateClaims()["email"].(string)
			if !ok {
				s.respond(w, r, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)
				return
			}

			r = r.WithContext(context.WithValue(r.Context(), emailKey, email))
			f.ServeHTTP(w, r)
		}

		return http.HandlerFunc(fn)
	}
}
