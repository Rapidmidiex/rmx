package user

import (
	"context"
	"net/http"
	"time"

	"github.com/lestrrat-go/jwx/v2/jwa"
	"github.com/lestrrat-go/jwx/v2/jwk"
	"github.com/lestrrat-go/jwx/v2/jwt"
	"github.com/rog-golang-buddies/rmx/internal"
)

// var refreshTokenCookieName = "RMX_DIRECT_RT"
// var refreshTokenCookiePath = "/api/v1"

// 400 - catch all
// 401 - unauthorized
// 403 - Forbidden
// 409 - Conflict (details already exist)
// 412 - Invalid precondition
// 422 - Unprocessable

func (s *Service) handleRegistration() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var v SignupUser
		if err := s.decode(w, r, &v); err != nil {
			s.respond(w, r, err, http.StatusBadRequest)
			return
		}

		var u internal.User
		if err := v.decode(&u); err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		if err := s.ur.SignUp(u); err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		s.created(w, r, u.ID.String())
	}
}

func (s *Service) handleIdentity() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		email := r.Context().Value(emailKey).(string)

		s.respond(w, r, email, http.StatusOK)
	}
}

func (s *Service) handleLogin(key jwk.Key) http.HandlerFunc {
	type loginUser struct {
		Email    internal.Email    `json:"email"`
		Password internal.Password `json:"password"`
	}

	type authTokens struct {
		IDToken     string `json:"idToken"`
		AccessToken string `json:"accessToken"`
	}

	return func(w http.ResponseWriter, r *http.Request) {
		var v loginUser
		if err := s.decode(w, r, &v); err != nil {
			s.respond(w, r, err, http.StatusBadRequest)
			return
		}

		u, err := s.ur.LookupEmail(v.Email)
		if err != nil {
			s.respond(w, r, err, http.StatusNotFound)
			return
		}

		if err := u.Password.Compare(v.Password); err != nil {
			s.respond(w, r, err, http.StatusUnauthorized)
			return
		}

		// -- Generate Tokens --
		var now = time.Now().UTC()
		its, ats, rts, err := s.signedTokens(key, now, string(u.Email), u.ID.String())
		if err != nil {
			s.respond(w, r, err, http.StatusInternalServerError)
			return
		}

		cookie := &http.Cookie{
			Name:     cookieName,
			Value:    string(rts),
			HttpOnly: true,
			Secure:   r.TLS != nil,
			SameSite: http.SameSiteLaxMode,
			Expires:  now.Add(time.Hour * 24 * 7),
		}

		var data = authTokens{
			IDToken:     string(its),
			AccessToken: string(ats),
		}

		s.respondCookie(w, r, data, cookie)
	}
}

func (s *Service) handleLogout() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		cookie := &http.Cookie{
			Name:     cookieName,
			Value:    "",
			HttpOnly: true,
			Secure:   r.TLS != nil,
			SameSite: http.SameSiteLaxMode,
			Expires:  time.Unix(0, 0),
		}

		s.respondCookie(w, r, nil, cookie)
	}
}

// still to develop
func (s *Service) handleRefresh(privateKey jwk.Key) http.HandlerFunc {
	type response struct {
		AccessToken string `json:"accessToken"`
	}

	return func(w http.ResponseWriter, r *http.Request) {
		// email := r.Context().Value(emailKey).(string)

		/*
			Claims & Tokens

			Token generated by cookie value
		*/

		nc := &http.Cookie{
			// Path:     "REFRESH_TOKEN_COOKIE_PATH",
			Name:     cookieName,
			Value:    "",
			HttpOnly: true,
			Secure:   r.TLS != nil,
			SameSite: http.SameSiteLaxMode,
			Expires:  time.Now().UTC().Add(time.Hour * 24 * 7),
		}

		data := response{
			AccessToken: "GEN_ACCESS_TOKEN",
		}

		s.respondCookie(w, r, data, nc)
	}
}

func (s *Service) authenticate(publicKey jwk.Key) func(f http.Handler) http.Handler {
	return func(f http.Handler) http.Handler {
		fn := func(w http.ResponseWriter, r *http.Request) {
			token, err := jwt.ParseRequest(r, jwt.WithHeaderKey("Authorization"), jwt.WithHeaderKey(cookieName), jwt.WithKey(jwa.RS256, publicKey), jwt.WithValidate(true))
			if err != nil {
				s.respond(w, r, err, http.StatusUnauthorized)
				return
			}

			email, ok := token.PrivateClaims()["email"].(string)
			if !ok {
				s.respond(w, r, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)
				return
			}

			// Convert email from `string` type to `internal.Email` ?
			r = r.WithContext(context.WithValue(r.Context(), emailKey, email))
			f.ServeHTTP(w, r)
		}

		return http.HandlerFunc(fn)
	}
}

const (
	cookieName = "RMX_DIRECT_RT"
)
